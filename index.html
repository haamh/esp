<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>ESP32 Health Monitor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>
</head>

<body>
    <h2>ESP32 Health Monitor</h2>
    <button onclick="connectBluetooth()">Connect to ESP32</button>
    <p id="status">Status: Disconnected</p>
    <p>BPM: <span id="bpm">0</span></p>
    <p>Avg BPM: <span id="avgBpm">0</span></p>
    <p>Steps: <span id="steps">0</span></p>
    <p>GSR: <span id="gsr">0</span></p>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.129.0/build/three.module.js';
        import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.129.0/examples/jsm/loaders/GLTFLoader.js';

        let scene, camera, renderer, model, mixer;
        const clock = new THREE.Clock();
        let actions = {};
        let activeAction, previousAction;
        let modelLoaded = false;
        let waveLoop;
        let prayLoop;
        let kissLoop;

        async function connectBluetooth() {
            try {
                const device = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    optionalServices: ['12345678-1234-5678-1234-56789abcdef0']
                });

                const server = await device.gatt.connect();
                document.getElementById("status").textContent = "Status: Connected";

                const service = await server.getPrimaryService('12345678-1234-5678-1234-56789abcdef0');
                const characteristic = await service.getCharacteristic('abcdef01-1234-5678-1234-56789abcdef1');

                characteristic.addEventListener("characteristicvaluechanged", handleData);
                await characteristic.startNotifications();
                console.log("Connected and receiving data...");
            } catch (error) {
                console.error("Bluetooth connection failed", error);
            }
        }

        function handleData(event) {
            try {
                let data = new TextDecoder().decode(event.target.value);
                console.log("Received Data:", data);

                let json = JSON.parse(data);
                document.getElementById("bpm").textContent = json.BPM;
                document.getElementById("avgBpm").textContent = json.AvgBPM;
                document.getElementById("steps").textContent = json.Steps;
                document.getElementById("gsr").textContent = json.GSR;

                // Trigger the appropriate animation based on the data
                if (json.BPM > 120) {
                    transitionToAnimation('run', 1, true, 'idle'); // BPM is high, run animation
                } else if (json.BPM > 90) {
                    transitionToAnimation('jog', 1, true, 'idle'); // BPM is moderate, jog animation
                } else if (json.Steps > 1000) {
                    transitionToAnimation('sweat', 1, true, 'idle'); // Many steps, sweat animation
                } else {
                    transitionToAnimation('idle', 1, true, 'jog'); // Default to idle if nothing else
                }
            } catch (err) {
                console.error("Error parsing JSON data:", err);
            }
        }

        function init() {
            const container = document.createElement('div');
            container.id = 'model-container';
            document.body.appendChild(container);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1, 3);

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFShadowMap;
            renderer.domElement.style.pointerEvents = 'none'; 
            document.body.appendChild(renderer.domElement);

            renderer.domElement.style.position = 'fixed';
            renderer.domElement.style.bottom = '-7vh'; 
            renderer.domElement.style.left = '-15vw';
            renderer.domElement.style.zIndex = '1';

            const directionalLight = new THREE.DirectionalLight(0xffffff, 4);
            directionalLight.position.set(2, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const ambientLight = new THREE.AmbientLight(0xffffff, 1);
            scene.add(ambientLight);

            const loader = new GLTFLoader();
            loader.load(
                'haamh.glb',
                function (gltf) {
                    model = gltf.scene;
                    model.scale.set(0.08, 0.08, 0.08);
                    model.rotation.y = THREE.MathUtils.degToRad(30);
                    scene.add(model);

                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    mixer = new THREE.AnimationMixer(model);
                    gltf.animations.forEach(clip => {
                        actions[clip.name] = mixer.clipAction(clip);
                    });

                    if (actions.idle) {
                        activeAction = actions.idle;
                        activeAction.play();
                    }

                    document.getElementById('loading-screen').style.display = 'none';
                    modelLoaded = true;
                },
                function (xhr) {
                    const progress = (xhr.loaded / xhr.total) * 100;
                    document.getElementById('progress-bar').style.width = progress + '%';
                    document.getElementById('loading-text').innerText = `Loading... ${Math.round(progress)}%`; 
                },
                function (error) {
                    console.error('Error loading model:', error);
                }
            );

            animate();
        }

        function transitionToAnimation(animationName, duration, loop = false, returnTo = null) {
            if (!actions[animationName] || activeAction === actions[animationName]) return;

            previousAction = activeAction;
            activeAction = actions[animationName];

            let actualDuration = activeAction.getClip().duration;
            if (previousAction) previousAction.fadeOut(duration);
            activeAction.reset().fadeIn(duration).play();

            if (loop) {
                activeAction.setLoop(THREE.LoopRepeat, Infinity);
            }
            activeAction.clampWhenFinished = true;

            if (returnTo) {
                setTimeout(() => {
                    if (activeAction === actions[animationName]) {
                        transitionToAnimation(returnTo, 0.5);
                    }
                }, actualDuration * 1000);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (mixer) mixer.update(clock.getDelta());
            renderer.render(scene, camera);
        }

        window.addEventListener('DOMContentLoaded', init);
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>

</html>
