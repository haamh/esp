<!DOCTYPE html>
<html lang="en">

<head>
    <title>ESP32 Health Monitor + 3D Model</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: transparent;
        }

        #modelContainer {
            width: 800px;
            height: 600px;
        }
    </style>
</head>

<body>
    <h2>ESP32 Health Monitor</h2>
    <button onclick="connectBluetooth()">Connect to ESP32</button>
    <p id="status">Status: Disconnected</p>

    <p>BPM: <span id="bpm">0</span></p>
    <p>Avg BPM: <span id="avgBpm">0</span></p>
    <p>Steps: <span id="steps">0</span></p>
    <p>GSR: <span id="gsr">0</span></p>

    <div id="modelContainer"></div>

    <script>
        const serviceUUID = "12345678-1234-5678-1234-56789abcdef0";
        const characteristicUUID = "abcdef01-1234-5678-1234-56789abcdef1";
        let characteristic;

        let scene, camera, renderer, loader, model, mixer, animations = {};

        function initScene() {
            console.log("Initializing 3D scene...");
            scene = new THREE.Scene();
            scene.scale.set(2, 2, 2);
            scene.position.set(-0.46, -1.4, 0);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
            camera.position.set(0, 0, 5);
            camera.updateProjectionMatrix();

            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            document.getElementById("modelContainer").appendChild(renderer.domElement);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 4);
            directionalLight.position.set(2, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 10),
                new THREE.ShadowMaterial({ opacity: 0.5 })
            );
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -1;
            ground.receiveShadow = true;
            scene.add(ground);

            loader = new THREE.GLTFLoader();
            loadBaseModel("EL2205.glb");


        }

        function loadBaseModel(file) {
            loader.load(file, (gltf) => {
                model = gltf.scene;
                mixer = new THREE.AnimationMixer(model);

                model.position.set(0, -1, 0);
                model.rotation.y = THREE.MathUtils.degToRad(25);
                scene.add(model);
                camera.lookAt(model.position);

                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                idleAction = mixer.clipAction(gltf.animations[0]);
                idleAction.play();
                console.log("Base model loaded:", file);
            });
        }


        function animate() {
            requestAnimationFrame(animate);
            if (mixer) mixer.update(0.016);
            
            // ðŸ”¥ Ensure model remains visible each frame
            if (model) {
                model.visible = true;
                model.traverse((child) => { 
                    if (child.isMesh) {
                        child.visible = true;
                    }
                });
            }

            renderer.render(scene, camera);
        }

       

        function playAnimation(animFile) {
            loader.load(animFile, (gltf) => {
                console.log("Loaded animation from:", animFile);
                
                if (gltf.animations.length > 0) {
                    if (activeAction) {
                        activeAction.stop();
                    }

                    let newClip = gltf.animations[0];
                    activeAction = mixer.clipAction(newClip, model);
                    activeAction.setLoop(THREE.LoopOnce);
                    activeAction.clampWhenFinished = true;
                    activeAction.play();

                    // ðŸ”¥ Ensure model stays visible
                    model.visible = true;
                    model.traverse((child) => { child.visible = true; });

                    // ðŸ”¥ Debugging Information
                    console.log("Animation clip name:", newClip.name);
                    console.log("Affected bones:", newClip.tracks.map(track => track.name));
                    console.log("Model visibility:", model.visible);
                    console.log("Model position:", model.position);
                    console.log("Model scale:", model.scale);
                    console.log("Model rotation:", model.rotation);
                    console.log("Playing animation:", animFile);

                    mixer.addEventListener('finished', (e) => {
                        if (e.action === activeAction) {
                            idleAction.reset().play();
                        }
                    });
                } else {
                    console.warn("No animations found in:", animFile);
                }
            }, undefined, (error) => {
                console.error("Error loading animation:", error);
            });
        }
        async function connectBluetooth() {
            try {
                const device = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    optionalServices: [serviceUUID]
                });

                const server = await device.gatt.connect();
                document.getElementById("status").textContent = "Status: Connected";

                const service = await server.getPrimaryService(serviceUUID);
                characteristic = await service.getCharacteristic(characteristicUUID);

                characteristic.addEventListener("characteristicvaluechanged", handleData);
                await characteristic.startNotifications();
                console.log("Connected and receiving data...");
            } catch (error) {
                console.error("Bluetooth connection failed", error);
            }
        }

        function handleData(event) {
            try {
                let data = new TextDecoder().decode(event.target.value);
                let json = JSON.parse(data);

                document.getElementById("bpm").textContent = json.BPM;
                document.getElementById("avgBpm").textContent = json.AvgBPM;
                document.getElementById("steps").textContent = json.Steps;
                document.getElementById("gsr").textContent = json.GSR;

                updateAnimation(json.BPM, json.Steps, json.GSR);
            } catch (err) {
                console.error("Error parsing JSON data:", err);
            }
        }

        function updateAnimation(bpm, steps, gsr) {
            if (bpm >= 120) {
                playAnimation('run');
            } else if (bpm >= 70 && steps > 0) {
                playAnimation('jog');
            } else if (gsr > 1000) {
                playAnimation('sweat');
            } else {
                playAnimation('idle');
            }
        }

        window.onload =  initScene();

    </script>

</body>

</html>
